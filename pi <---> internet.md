# overview
i wanna let the internet talk to servers on my raspberry pi. How do i go about doing this?

according to some resources, here are the general steps:
1. assign a static ip address to the pi on the local network
2. update the configuration of your router to port forward inbound traffic to your pi
3. setup ddns
4. setup nginx as reverse proxy to support multiple servers


# assign static ip address to your pi
the raspberry pi defaults to using a dynamic IP address assigned by the DHCP server (most likely your network router). we want to set it to be static instead.
### network information
we need to learn a bit about our network before we do anything.

1. get the **default gateway ip**. this is the local ip address of our router. all connected devices talk to this in order to access the internet or other devices connected on the local network.
   ```shell
   $ netstat -nr
   Kernel IP routing table
   Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
   0.0.0.0         192.168.66.1    0.0.0.0         UG        0 0          0 wlan0
   192.168.66.0    0.0.0.0         255.255.255.0   U         0 0          0 wlan0
   ```
   we can see that `192.168.66.1` is our *gateway ip*.
2. get the **DNS server ip**. this is most likely the same as the gateway ip since your router might be acting as your DNS server.
   ```shell
   $ cat /etc/resolv.conf
   # Generated by resolvconf
   nameserver 192.168.66.1
   ```
3. get our pi's **local ip** address and broadcast address
   ```shell
   $ ip -a addr show | grep global
   inet 192.168.66.145/24 brd 192.168.66.255 scope global wlan0
   ```
### update dhcpcd.conf
we need to now tell the dhcp server that we don't want a dynamic ip address, but we will be using a static one. we can do this by making some updates to the `/etc/dhcpcd.conf` file. this file is the configuration for the dhcp client daemon which runs on our pi and communicates with the dhcp server. Here are the changes we need to make to `/etc/dhcpcd.conf`:
```shell
interface wlan0
static ip_address=192.168.66.145/24
static routers=192.168.66.1
static domain_name_servers=192.168.66.1
```
in the changes above, we are using the info we gathered previously and mapped
* *ip_address* <--> *local ip*
* *routers* <--> *gateway ip*
* *domain_name_servers* <--> *DNS server ip*

### reboot your pi
# update router config to port forward inbound trafic to pi
now we need to configure our router to port forward a port on the router's public ip to a port on our pi's static local network ip. to do this we need to login to our router's admin portal. go to your web browser and go to your router ip. In the previous step we found that the router (gateway) ip is `192.168.66.1`, so lets go there in our browser. You should be presented with the login screen for your router. Usually the username and password are both `admin` so you should probably change this to something more secure.

this step will be highly depenedent on what router you have. generally, you want to find a way to configure port forwarding and then forward a port on the router's public ip to a port on your pi's static local ip address using all protocols.

# dynamic dns
just like how, by default, a device connecting onto the local network is dynamically assigned an ip address by your router, your *router* is dynamically re-assigned an ip address by your internet service provider (ISP) quite frequently. if we want to be able to connect to our router from the outside world (via a domain name we own or something) without having to always re-lookup our router's exposed ip address, then we are going to have to stay up-to-date with what our router's ip address everytime it changes. *Dynamic DNS* (DDNS) to the rescue!
### what is DDNS?
its basically an approach for your local computer to broadcast changes to its router's public ip address to some external service which wants to keep up-to-date with your ip address. There are a couple ways of going about this,
1. **your router has a DDNS client built into it**: your router detects when its public ip changes and then broadcasts this to a service which wants to know. the services that a router can broadcast to might be limited so, for example, if you have a domain registered with namecheap and your router doesn't broadcast to the namecheap ddns service, then you are out of luck.
2. **use a ddns service**: there are free online ddns service providers which will give you a domain name which will not change and sync to a ddns client daemon you run on your computer (or if your router can broadcast to that ddns service you can use the ddns client built into your router instead of running one on your computer) which will sync the changing public ip address of your router to the domain name that the ddns service provider has given you. if you already have a domain name (from namecheap for example) this means that you are registering for another intermediate domain name which is annoying. so this solution is just one more extra service to deal with.
3. **use a ddns client on your machine**: on linux there is a nice ddns client called [`ddclient`](https://github.com/ddclient/ddclient) which supports a bunch of ddns service providers including namecheap. since we can setup ddns with a domain name we've registered through namecheap, we will just use this.

### `ddclient`
here is a [useful blog post](https://blog.dembowski.net/2013/namecheap-dynamic-dns-setup-with-ddclient/) i read about setting up `ddclient` to work with namecheap ddns.
1. log into namecheap, go to domain list -> advanced dns -> add new record `A + Dynamic DNS Record`
2. set the `Host` to be `@` (the root domain (or `www` if you want this to point to `www.yourdomain.tld`)) and the `IP Address` to be some dummy address like `127.0.0.1` since our `ddclient` is going to overwrite this once it starts working.
3. still on namecheap, there should be an option to enable ddns, which you should do and then it will give you a long Dynamic DNS Password.
4. on your pi, install the `ddclient`
   ```shell
   $ sudo apt-get install ddclient
   ```
   you should be prompted to answer some questions, but it doesn't matter cuz you'll be editing the configuration anyway.
5. now edit the `/etc/ddclient.conf` on your pi to look something like
   ```shell
   # /etc/ddclient.conf
   
   #############   
   # namecheap #
   #############   
   use=web, web=dynamicdns.park-your-domain.com/getip
   ssl=yes
   protocol=namecheap
   server=dynamicdns.park-your-domain.com
   login=slime.church
   password='your namecheap ddns password'
   @
   ```
6. remove the cache of the original config asked for by the prompt
   ```shell
   $ sudo rm /var/cache/ddclient/ddclient.cache
   ```
7. restart ddclient
   ```shell
   $ sudo ddclient
   ```
8. configure `ddclient` to run as a daemon, open `/etc/default/ddclient`
   ```shell
   run_daemon="true"
   ```
9. start the ddclient daemon, `sudo service ddclient start`
   
this is another [good blog post](https://samhobbs.co.uk/2015/01/dynamic-dns-ddclient-raspberry-pi-and-ubuntu) which says something at the end about dynamic dns providers timing out if there are no updates in a while, but i won't worry about that for now.

# nginx reverse proxy
since our dns records for any domain we wish to host on a machine(s) on our LAN will all point to the same ip address (the public ip address of our router) on port 80, we want to setup a reverse proxy server which our router forwards all incoming traffic to. The reverse proxy should be able to use the `host` field within any request to direct traffic to the appropriate location within the LAN. we will use nginx for this since it is pretty straight forward to setup.

### install and run nginx on pi
```shell
$ sudo apt-get install nginx
$ sudo systemctl enable nginx
$ sudo systemctl start nginx
```

### edit the nginx configuration
edit the `/etc/nginx/conf.d/default.conf`,
```shell
## Basic reverse proxy server ##

server_names_hash_bucket_size 100;

## someservice service on slime.church ##
upstream someservice  {
      server 127.0.0.1:3141; #someservice                                                                            
}

## Start slime.church static landing page ##
server {
    listen       80;
    server_name  slime.church;

    access_log  /var/log/nginx/slime.church.access.log  combined;
    error_log  /var/log/nginx/slime.church.error.log;
    root   /home/pi/Public;
    index  index.html index.htm;
}
## End slime.church ##

## START someservice.slime.church ##
server {
       listen      80;
       server_name someservice.slime.church;
       access_log  /var/log/nginx/someservice.slime.church.access.log  combined;
       error_log   /var/log/nginx/someservice.slime.church.error.log;

       location / {
                proxy_pass  http://someservice;
                proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
                proxy_redirect off;
                proxy_buffering off;
                proxy_set_header        Host            someservice.slime.church;
                proxy_set_header        X-Real-IP       $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        }
}
```
this configuration defines the directory for a static site to be served for `slime.church` and also a dynamic server to be proxied to for `someservice.slime.church`.

ok. we should be good for now.
